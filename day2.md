# day2

​																																																时间：2022年4月7日10:35:57

## 目录

类初始化和实例初始化

值传递和引用传递

## 一、类初始化和实例初始化

### 1.类初始化

#### a.步骤

- 一个类要创建实例需要先加载并初始化该类
  - main方法所在的类需要先加载和初始化
- 一个子类要初始化需要先初始化父类
- 一个类初始化就是执行<clinit>()方法
  - <clinit>() 方法由静态类变量显示赋值代码和静态代码块组成
  - 类变量显示赋值代码和静态代码块代码从上到下顺序执行
  - <clinit>()方法只执行一次

#### b.示例

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1649299808540.png" alt="1649299808540" style="zoom: 50%;" />

```
类构造
	父类初始化<clinit>
		1.静态变量显示赋值代码：j = method()
		2.静态代码块：(1)
		3.这两个从上到下顺序执行
	子类的初始化<clinit>
		1.先初始化父类
		2.静态变量显示赋值代码：j = method()
		3.静态代码块：(6)
		4.这两个从上到下顺序执行
	结果：(5)(1)(10)(6)
```



### 2.实例初始化

#### a.步骤

- <init>()方法可能重载有多个，有几个构造器就有几个<init>方法

- <init>() 方法由**非静态实例变量显示赋值代码**和**非静态代码块**、**对应构造器代码**组成

- **非静态实例变量显示赋值代码**和**非静态代码块代码**从上到下顺序执行，而对应构造器的代码最后执行

- 每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法

- <init>方法的首行是super ()或super(实参列表)，即对应父类的<init>方法

  ```
  注：super方法默认在首行，不写也有
  ```

#### b.示例

```
实例构造
	父类实例初始化
		1.i = test()
		2.父类的非静态代码块
		3.父类的构造器
	子类实例初始化
		1.super()
		2.i = test()
		3.子类的非静态代码块
		4.子类的构造器
结果：后序再说
```

#### c.this问题

- 非静态方法前面其实有一个默认的对象this

- this在构造器(或<init>)它表示的是正在创建的对象，因为这里是在创建Son对象，所以

- test()执行的是子类重写的代码( 面向对象多态)
- 所以在执行super的时候，**父类中的this是子类正在初始化的实例**，调用的方法也自然是**子类的test()方法**

```
结果
	父类
		1.i = test()：(9)
		2.非静态代码块：(3)
		3.构造器：     (2)
	子类
		1.super()：   (9) (3) (2)
		2.i = test()  (9)
		2.非静态代码块：(8)
		4.构造器：     (7)
结果：(9) (3) (2) (9) (8) (7)

加上之前的类构造，就是最终结果
```

### 3.方法重写的Override

#### a.那些方法不可以被重写

- final方法

- 静态方法

- private等子类中不可见方法

#### b.对象的多态性

- 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码
- 非静态方法默认的调用对象是this
- this对象在构造器或者说<init>方法中就是正在创建的对象

### 4.注意点

- 代码块和成员的初始化是顺序执行的
- 父类中的this，指向的是子类正在创建的对象

## 二、值传递和引用传递

### 1.基本数据类型：值传递

### 2.引用数据类型

- 地址传递
- String和包装类的不可变性

```
String类和包装类
	传递的任然是引用，但是在修方法中改的时候，会生成一个新的数据放入堆中，并将形参的值设为新的值的地址
	实参的地址以及堆中的值没有发生任何变化
	
Integer类
	凡是new的对象，即使值相等，引用也是不同的，但是可以使用equals()判断值
		Integer int1 = new Integer(127);
		Integer int2 = new Integer(127);
		int1 == int2; // false
		int1.equals(int2); //true
	jdk提供了-128~127的缓存，如果代码中使用了，就直接获取，所以Integer对象的引用是相同的(不是new出来的)
		Integer int1 = 127;
		Integer int2 = 127;
		int1 == int2; // true
```

### 3.示例

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1649305391562.png" alt="1649305391562" style="zoom:50%;" />

重点在于理解堆栈结构以及常量池

## 三、编程题（台阶问题）

### 1.问题

有n阶台阶，每次可以走1或者2步，有几种走法（有点类似于斐波那契）

### 2.递归

#### a.思路

- 可以想象成最后一次走就到顶了
- 由于最后一次可以走1或者2，所以需要求前n-1阶的走法+前n-2阶走法
- <img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1649342091105.png" alt="1649342091105" style="zoom: 50%;" />

#### b.代码实现

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1649341313945.png" alt="1649341313945" style="zoom:67%;" />

### 3.非递归

#### a.思路

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1649342215332.png" alt="1649342215332" style="zoom:50%;" />

#### b.代码实现

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1649342238748.png" alt="1649342238748" style="zoom: 67%;" />

### 4.总结

- 递归可读性强，代码量少，但是效率可能慢
- 迭代可读性查，代码量多， 但是效率非常高